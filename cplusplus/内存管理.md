# 内存管理


## 内存碎片 157
- 内存池
1. 提前分配预估数量的内存，然后通过 MemoryBlock* 进行索引
    ```c
    //MemoryBlock 结构体说明
    //内存块大小
    struct MemoryBlock
    {
        // 当前块 id
        int nId;
        //应用计数
        int nRef;
        //所属内存池分配器
        MemoryAlloctor* pAlloctor;
        //下一个内存块
        MemoryBlock* pNext;
        //是否在池中
        bool bPool;
    };
    
    //每一块的大小
    const static size_t eachBlockSize = _nBlockSize + sizeof(MemoryBlock);
    //总的大小
    const static size_t totalSize = eachBlockSize * _nBlockNum;
    _pBuf = (char*)malloc(totalSize);
    /*
    初始化每一块内存数据头
    */
    //初始化头
    _pHeader = (MemoryBlock*)_pBuf;
    _pHeader->bPool = true;
    _pHeader->nId = 0;
    _pHeader->nRef = 0;
    _pHeader->pNext = nullptr;
    _pHeader->pAlloctor = this;

    MemoryBlock* pTemp = _pHeader;
    for (int i = 1; i < _nBlockNum; i++)
    {
        MemoryBlock* pCurBlock = (MemoryBlock*)(_pBuf + eachBlockSize * i);
        //参考初始化头

        //让当前块与前一块串联起来
        pTemp->pNext = pCurBlock;
        pTemp = pCurBlock;
    }
2. 根据块大小、数量生成具体的内存池（参考操作系统的磁盘文件申请机制）。注意，内存对齐问题。    
    ```c
    //内存对齐
    size_t pointerLen = sizeof(void*);

    if (nBlockSize%pointerLen != 0)
    {
        _nBlockSize = (nBlockSize / pointerLen + 1) * pointerLen;
    }
    else {
        _nBlockSize = nBlockSize;
    }

    //根据块大小、数量生成具体的内存池
    template<size_t nBlockSize, size_t nBlockNum>
    class MemoryPool : public MemoryAlloctor
    {
    public:
        MemoryPool()
        {
            _nBlockSize = nBlockSize;
            _nBlockNum = nBlockNum;
        }
    };

    //具体的64大小的池
    MemoryPool<64, 1000> _pool64;

    // 0-64 范围内的都按64分配
	init(0, 64, &_pool64);

3. 通过申请的大小快速定位具体的内存池，然后取出分配好的内存
    ```c
    //让指定大小范围的内存需求定向到对应的 pool
	void init(int nBegin, int nEnd, MemoryAlloctor* pool)
	{
		for (int n = nBegin; n < nEnd; n++)
		{
			_allPool[n] = pool;
		}
	}
    
    //分配内存
	void* allocMem(size_t nSize)
	{
        //最大块范围之内
		if (nSize <= MAX_MEMORY_SIZE)
		{
			return _allPool[nSize]->allocMemory(nSize);
		}
		//超出最大块范围
		else {
            //...
		}
	}
- 对象池

## 内存正确释放
- 智能指针


## 智能指针
- std::unique_ptr <专属所有权语义>
    1. 拥有所指涉及到的资源
    2. 移动一个 unique_ptr 会将所有权从源指针移致目标指针
    3. 执行析构时，通过非空的 unique_ptr 析构其资源
    4. 高效地转换成 std::shared_ptr
- 常见用法：
    1. 工厂函数的返回类型
        ```c
        class Investment {
            virtual ~Investment();
        };
        class Stock : public Investment {...};
        class Bond : public Investment {...};
        class RealEstate: public Investment {...};

        template<typename... Ts>
        auto makeInvestment(Ts&&... params) //c++14用法
        {
            auto delInvmt = [](Investment* pInvestment)
            {
                makeLogEntry(pInvestment);
                delete pInvestment;
            };
            std::unique_ptr<Investment, decltype(delInvmt)> pIv(nullptr, delInvmt);
            if (/*应创建一个 Stock 类型的对象*/) {
                pIv.reset(new Stock(std::forward<Ts>(params)...));
            } else if (/*应创建一个 Bond 类型的对象*/){
                pIv.reset(new Bond(std::forward<Ts>(params)...));
            } else if (/*应创建一个 RealEstate 类型的对象*/){
                pIv.reset(new RealEstate(std::forward<Ts>(params)...));
            }
            return pInv;
        }
